---
layout: post
title: 计算机基础 - 负数的二进制表示
date: 2023-07-05 14:44:45 +0800
categories: [计算机原理, 二进制]
tags: [计算机原理, 二进制]
author: 
---

>在[计算机运算](https://zh.wikipedia.org/wiki/计算_(计算机科学))中，**有符号数的表示**（英语：**signed number representations**）需要将负数编码为二进制形式。
>
>在[数学](https://zh.wikipedia.org/wiki/数学)中，任意基数的负数都在最前面加上“−”符号来表示。然而在计算机[硬件](https://zh.wikipedia.org/wiki/硬件)中，数字都以无符号的二进制形式表示，因此需要一种[编码](https://zh.wikipedia.org/wiki/编码)[负号](https://zh.wikipedia.org/wiki/負號)的方法。当前有四种方法，用于扩展[二进制数字系统](https://zh.wikipedia.org/wiki/二進制數字系統)，来表示有符号数：**[原码](https://zh.wikipedia.org/wiki/原码)**（sign-and-magnitude）、**[反码](https://zh.wikipedia.org/wiki/反码)**（ones' complement）、**[补码](https://zh.wikipedia.org/wiki/补码)**（two's complement）以及**[移码](https://zh.wikipedia.org/wiki/移码)**（offset binary，excess-*N*）。

## 表示法

### 1. 正数 5 的表示法
假设有一个 int 类型的数，值为 5，那么，我们知道它在计算机中表示为：
00000000 00000000 00000000 00000101
5 转换成二制是 101，不过 int 类型的数占用 4 字节（32位），所以前面填了一堆 0。

### 2. 负数 -5 的表示法
现在想知道，-5 在计算机中如何表示？**在计算机中，负数以原码的补码形式表达。**

## 概念

原码、反码、补码，是表示带符号[二进制数](https://zh.wikipedia.org/wiki/二进制数)的最常用的方法。

### 1. 原码
所谓**原码**，就是一个**符号位加原数绝对值。**

表面上，原码已经可以表示出一些数字了，但是在实际的计算机中会引发一些问题。
例如，0 和 -0 的八位二进制原码分别是 00000000 和 10000000 ，但事实上它们俩是同一个数。所以，这就需要引进反码和补码的概念。

### 2. 反码 （ones' complement）
所谓**反码**，就是 **除了符号位** ，其他每一位都是原码对应位 **异或 1** 的值。
与原码同样，反码不能将 0 和 -0 看作同一个数。

+ n >= 0, 反码与原码形式一样
+ n   < 0, **符号位不变，其余各位按位取反**

对两个反码表示形式的数字做加法，首先需要进行常规的二进制加法，但还需要在和的基础上加上[进位](https://zh.wikipedia.org/w/index.php?title=进位标志&action=edit&redlink=1)。为什么必须这样呢？来看下面这个−1加上+2的例子。

```java
       二进制    十进制
    11111110     -1
 +  00000010     +2
............    ...
  1 00000000      0   <-- 错误答案
           1     +1   <-- 加上进位
............    ...
    00000001      1   <-- 正确答案
           
----------------------------------------
           
       二进制    十进制
    11111110     -1
 +  00001000     +8
............    ...
  1 00000110      6   <-- 错误答案
           1     +1   <-- 加上进位
............    ...
    00000111      7   <-- 正确答案
```



### 3. 补码 （two's complement）
那么，既然原码和反码都不能很好的将0和-0化为同一个数，这时候，**补码**就派上用场了。
+ n >= 0 时，补码与原码相同。
+ n   < 0 时，则是 **反码 +1** 。

**补码**（two's complement）回避了 0 有多种表示的问题以及循环进位的需要。

下表列出了 4-bit 二进数所能表示的整数：

| 二进制数 | 无符号 | 有符号 | 反码(一补码（ones' complement）) | 补码(二补码（two's complement）) |
| -------- | ------ | ------ | -------------------------------- | -------------------------------- |
| 0000     | 0      | 0      | 0                                | 0                                |
| 0001     | 1      | 1      | 1                                | 1                                |
| 0010     | 2      | 2      | 2                                | 2                                |
| 0011     | 3      | 3      | 3                                | 3                                |
| 0100     | 4      | 4      | 4                                | 4                                |
| 0101     | 5      | 5      | 5                                | 5                                |
| 0110     | 6      | 6      | 6                                | 6                                |
| 0111     | 7      | 7      | 7                                | 7                                |
| 1000     | 8      | -0     | -7                               | -8                               |
| 1001     | 9      | -1     | -6                               | -7                               |
| 1010     | 10     | -2     | -5                               | -6                               |
| 1011     | 11     | -3     | -4                               | -5                               |
| 1100     | 12     | -4     | -3                               | -4                               |
| 1101     | 13     | -5     | -2                               | -3                               |
| 1110     | 14     | -6     | -1                               | -2                               |
| 1111     | 15     | -7     | -0                               | -1                               |

练习:

| 数字 | 源码      | 反码      | 补码      |
| ---- | --------- | --------- | --------- |
| -0    | 1000_0000 | 1111_1111 | 0000_0000 |
| 0    | 0000_0000 | 0111_1111 | 0000_0000 |
| 1    | 0000_0001 | 0111_1110 | 0000_0000 |
| -1   | 1000_0001 | 1111_1110 | 1111_1111 |
| 127  | 0111_1111 | 0000_0000 | 0000_0001 |
| -127 | 1111_1111 | 1000_0000 | 1000_0001 |
| -128 |  |  |  |

