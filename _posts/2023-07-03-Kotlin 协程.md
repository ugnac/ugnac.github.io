---
layout: post
title: Kotlin 协程
date: 2023-07-03 14:44:45 +0800
categories: [Kotlin, 协程]
tags: [Kotlin, 协程]
author: 
---

> 本篇大部分内容来自:
>
> [Kotlin 的协程用力瞥一眼 - 学不会协程？很可能因为你看过的教程都是错的 (rengwuxian.com)](https://rengwuxian.com/kotlin-coroutines-1/)
>
> 参考: 
>
> [kotlin协程的简述和使用 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/568437065)
>
> [一文看透 Kotlin 协程本质 - 掘金 (juejin.cn)](https://juejin.cn/post/6987724340775108622)

## 什么是协程?

协程并不是 Kotlin 提出来的新概念，其他的一些编程语言，例如：Go、Python 等都可以在语言层面上实现协程，甚至是 Java，也可以通过使用扩展库来间接地支持协程。

当在网上搜索协程时，我们会看到：

- Kotlin 官方文档说「本质上，协程是轻量级的线程」。
- 很多博客提到「不需要从用户态切换到内核态」、「是协作式的」等等。

作为 Kotlin 协程的初学者，这些概念并不是那么容易让人理解。这些往往是作者根据自己的经验总结出来的，只看结果，而**不管过程就不容易理解协程**。

「协程 Coroutines」源自 Simula 和 Modula-2 语言，这个术语早在 1958 年就被 [Melvin Edward Conway](https://rengwuxian.com/kotlin-coroutines-1/[https://zh.wikipedia.org/wiki/马尔文·康威](https://zh.wikipedia.org/wiki/马尔文·康威)) 发明并用于构建汇编程序，说明**协程是一种编程思想**，并不局限于特定的语言

Go 语言也有协程，叫 Goroutines，从英文拼写就知道它和 Coroutines 还是有些差别的（设计思想上是有关系的），否则 Kotlin 的协程完全可以叫 Koroutines 了。

因此，对一个新术语，我们需要知道什么是「标准」术语，什么是变种。

当我们讨论协程和线程的关系时，很容易**陷入中文的误区**，两者都有一个「程」字，就觉得有关系，其实就英文而言，Coroutines 和 Threads 就是两个概念。

从 Android 开发者的角度去理解它们的关系：

- 我们所有的代码都是跑在线程中的，而线程是跑在进程中的。
- 协程没有直接和操作系统关联，但它不是空中楼阁，它也是跑在线程中的，可以是单线程，也可以是多线程。
- 单线程中的协程总的执行时间并不会比不用协程少。
- Android 系统上，如果在主线程进行网络请求，会抛出 `NetworkOnMainThreadException`，对于在主线程上的协程也不例外，这种场景使用协程还是要切线程的。

要理解协程, 首先需要理解协程到底解决了哪一方面的问题?

## 解决了什么问题?

协程设计的初衷是为了**解决并发问题**，让 「协作式多任务」 实现起来更加方便。可以让程序员使用**同步的方式编写异步代码**。

也就是说, 协程本质上解决的是 **并发问题**

什么是并发?  首先要理解 **并发** 和 **并行** 的概念

+ **并发:**

+ **并行:**



## 协程

Kotlin 编写异步代码的方式是使用协程， 这是一种计算可被挂起的想法。 即一种函数可以在某个时刻暂停执行并稍后恢复的想法  

协程的一个好处是， 当涉及到开发人员时， 编写非阻塞代码与编写阻塞代码基本相同。 编程模型本身并没有真正改变  

以下面的代码为例：  

```java
fun postItem(item: Item) {
    launch {
        val token = preparePost()
        val post = submitPost(token, item)
        processPost(post)
    }
}

suspend fun preparePost(): Token {
    // 发起请求并挂起该协程
    return suspendCoroutine {
        // ...
    }
}
```

此代码将启动长时间运行的操作， 而不会阻塞主线程。 `preparePost` 就是所谓的 可挂起的函
数 ， 因此它含有 `suspend` 前缀。 这意味着如上所述， 该函数将被执行、 暂停执行以及在某个
时间点恢复  

+ 该函数的签名保持完全相同。 唯一的不同是它被添加了 suspend 修饰符。 但是返回类型依然是我们想要的类型。
+ 编写这段代码代码就好像我们正在编写同步代码， 自上而下， 不需要任何特殊语法， 除了使用一个名为 launch 的函数， 它实质上启动了该协程（ 在其他教程中介绍） 。
+ 编程模型和 API 保持不变。 我们可以继续使用循环， 异常处理等， 而且不需要学习一整套新的 API。
+ 它与平台无关。 无论我们是面向 JVM， JavaScript 还是其他任何平台， 我们编写的代码都是相同的。 编译器负责将其适应每个平台  

